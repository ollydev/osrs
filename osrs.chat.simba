{$DEFINE INCLUDED_CHAT}
{$include_once osrs.simba}

type
  TRSChat = record
    Bounds: TBox;
    LineBoxes: TBoxArray;
    InputLineBox: TBox;
  end;

function TRSChat.GetDisplayNameBox(out Color: TColor): TBox; overload;
var
  TPA: TPointArray;
begin
  for Color in [$FFFFFF, $000000] do
  begin
    TPA := Target.FindColor(Color, 0, Self.InputLineBox);
    if (Length(TPA) > 0) then
      Exit(TPA.Bounds());
  end;
end;

function TRSChat.GetDisplayNameBox(): TBox; overload;
var
  _: TColor;
begin
  Result := Self.GetDisplayNameBox(_);
end;

function TRSChat.GetDisplayName(): String;
begin
  Result := OCR.RecognizeStatic(Self.InputLineBox, FONT_PLAIN_12, [Colors.WHITE], 0);
  if (Result.Pop <> ':') then
    Result := '';
end;

function TRSChat.GetLineText(Line: Integer): String;
const
  StaticOffset = 2; // Make static text placement so static recognition can be used

  function RecognizeTransparent(b: TBox): String;
  var
    Image: TImage;
    TPA: TPointArray;
  begin
    Image := TImage.CreateFromTarget(b);

    // First shadow from above line draws over our line.
    // Mark the shadow as a match since OCR requires 100% character match.
    TPA := Image.FindColor($000000, 0, [0, StaticOffset, Image.Width, StaticOffset]);
    Image.DrawColor := $FFFFFF;
    Image.DrawTPA(TPA);

    // Now find shadows, offset by -1,-1 to find colors of text
    TPA := Image.FindColor(0, 0, [1, 1, Image.Width, Image.Height]);
    TPA := TPA.Offset([-1,-1]).ExcludePoints(TPA);
    Image.ReplaceColorBinary(False, Image.GetColors(TPA).Unique, 0);

    Result := OCR.Engine.Recognize(Image, FONT_PLAIN_12, [0,0]);

    Image.Free();
  end;

  function Recognize(b: TBox): String;
  const
    BG_COLOR: TColorTolerance = [$6793AA, 3.287, EColorSpace.HSL, [2.025, 0.581, 0.395]];
  var
    TPA: TPointArray;
    TextColors: TColorArray;
  begin
    TPA := Target.FindColor(BG_COLOR, B).Invert();
    TextColors := Target.GetColors(TPA).Unique();

    Result := OCR.Recognize(b, FONT_PLAIN_12, TextColors, 0);
  end;

var
  B: TBox;
begin
  B := Self.LineBoxes[Line];
  B.Y1 -= StaticOffset;

  if Self.IsTransparent() then
    Result := RecognizeTransparent(B)
  else
    Result := Recognize(B);
end;

function TRSChat.GetText: TStringArray;
var
  I: Integer;
begin
  SetLength(Result, Length(Self.LineBoxes));
  for I := 0 to High(Result) do
    Result[I] := Self.GetLineText(I);
end;

function TRSChat.IsTransparent: Boolean;
var
  Color: TColor;
begin
  Self.GetDisplayNameBox(Color);

  Result := Color = (Colors.WHITE);
end;

procedure TRSChat.Setup;
begin
  Self.Bounds := InterfaceUtils.BoundsFromBottomLeft([0, -165], 518, 141);
  Self.LineBoxes := TBoxArray.Create([Self.Bounds.X1 + 10, Self.Bounds.Y1 + 8], 1, 9, Self.Bounds.Width - 35, 13, [0, 1]);
  Self.InputLineBox := Self.LineBoxes.Pop;
  Self.InputLineBox.Y2 += 2;
end;

var
  Chat: TRSChat;
