{$DEFINE INCLUDED_CHAT}
{$include_once osrs.simba}

type
  TRSChat = record
    Bounds: TBox;
    LineBoxes: TBoxArray;
    InputLineBox: TBox;
  end;

function TRSChat.GetDisplayNameBox(out Color: TColor): TBox; overload;
var
  TPA: TPointArray;
  B: TBox;
begin
  B := Self.InputLineBox;
  for Color in [$FFFFFF, $000000] do
  begin
    TPA := Target.FindColor(Color, 0, B);
    if Length(TPA) then
      Exit(TPA.Bounds());
  end;
end;

function TRSChat.GetDisplayNameBox(): TBox; overload;
var
  Color: TColor;
begin
  Result := Self.GetDisplayNameBox(Color);
end;

function TRSChat.GetDisplayName(): String;
var
  Color: TColor;
begin
  Result := OCR.Recognize(Self.GetDisplayNameBox(Color).Expand(2), TOCRColorFilter.Create([Color]), FONT_PLAIN_12);
  Result := Result.TrimRight([':']);
end;

function TRSChat.GetLineText(Line: Integer): String;
const
  StaticOffset = 2; // Make static text placement so RecognizeStatic can be used
  Background: TColorTolerance = [$6793AA, 3.287, EColorSpace.HSL, [2.025, 0.581, 0.395]];
var
  B: TBox;
  X, Y: Integer;
  BackgroundInv: TPointArray;
  Color: TColor;
  Colors: TColorArray;
  Mat: TIntegerMatrix;
begin
  B := Self.LineBoxes[Line];
  B.Y1 -= StaticOffset;

  if Self.IsTransparent() then
  begin
    Mat := Target.GetColorsMatrix(B);

    // Shadow from above line draws over our line.
    // Mark the shadow as a match since OCR requires 100% character match.
    for X := 0 to B.Width - 1 do
      if (Mat[StaticOffset, X] = 0) then
        Mat[StaticOffset, X] := $FFFFFF;

    // Get colors from shadow -1,-1
    for Y:=1 to Mat.Height - 1 do
      for X:=1 to Mat.Width - 1 do
        if (Mat[Y, X] = 0) and (Mat[Y-1, X-1] <> 0) then
          Colors += Mat[Y-1, X-1];

    Result := OCR.RecognizeStatic(Mat, TOCRColorFilter.Create(Colors.Unique()), FONT_PLAIN_12);
  end else
  begin
    BackgroundInv := Target.FindColor(Background, B).Invert();
    Colors := Target.GetColors(BackgroundInv).Unique();

    Result := OCR.RecognizeStatic(B, TOCRColorFilter.Create(Colors), FONT_PLAIN_12);
  end;
end;

function TRSChat.GetText: TStringArray;
var
  I: Integer;
begin
  SetLength(Result, Length(Self.LineBoxes));
  for I := 0 to High(Result) do
    Result[I] := Self.GetLineText(I);
end;

function TRSChat.IsTransparent: Boolean;
var
  Color: TColor;
begin
  Self.GetDisplayNameBox(Color);

  Result := Color = (Colors.WHITE);
end;

procedure TRSChat.Setup;
begin
  Self.Bounds := InterfaceUtils.BoundsFromBottomLeft([0, -165], 518, 141);
  Self.LineBoxes := TBoxArray.Create([Self.Bounds.X1 + 10, Self.Bounds.Y1 + 8], 1, 9, Self.Bounds.Width - 35, 13, [0, 1]);
  Self.InputLineBox := Self.LineBoxes.Pop;
end;

var
  Chat: TRSChat;
